program sl.aleo {
    // ========== CONSTANTS ==========

    // Tick size in basis points (100 = 0.01 = 1 cent for prices around $1-10)
    const TICK_SIZE: u64 = 100u64;

    // Maximum tick range a single order can span (prevents abuse)
    const MAX_TICK_RANGE: u64 = 50u64; // e.g., $0.50 range for $1-10 tokens

    // Matcher fee in basis points (5 = 0.05%)
    const MATCHER_FEE_BPS: u64 = 5u64;

    // Trading fee in basis points (10 = 0.10%)
    const TRADING_FEE_BPS: u64 = 10u64;

    // ========== DATA STRUCTURES ==========

    // Record representing a private order
    record TickOrder {
        // Identity (owner is always private in records)
        owner: address,

        // Market Info (public)
        token_pair: u64,        // e.g., 1 = USDC/ALEO

        // Tick Range (public - enables matching)
        tick_lower: u64,        // Minimum acceptable price tick
        tick_upper: u64,        // Maximum acceptable price tick

        // Order Details (private)
        is_buy: bool,           // true = buy, false = sell
        quantity: u64,          // Order size in base units
        limit_price: u64,       // Exact limit price within tick range

        // State
        filled: u64,            // Amount filled so far
        timestamp: u32,         // Block height when created
    }

    // Public state tracking aggregate tick information
    struct TickInfo {
        token_pair: u64,
        tick_id: u64,
        order_count: u32,           // Total number of active orders in this tick
        total_volume_settled: u64,  // Cumulative settled volume (public metric)
        last_updated: u32,
    }

    // Settlement record for completed trades
    record Settlement {
        owner: address,             // Party receiving this settlement
        token_pair: u64,
        quantity: u64,              // Amount traded
        price: u64,                 // Execution price
        is_buy: bool,               // Whether this party was buyer
        timestamp: u32,
    }

    // ========== MAPPINGS (Global State) ==========

    // Maps tick_key (hash of token_pair + tick_id) to TickInfo
    mapping tick_registry: field => TickInfo;

    // Maps order_id to fill status (for preventing double-spending)
    mapping order_fills: field => u64;

    // Maps tick_key to total settled volume (for price discovery)
    mapping tick_volumes: field => u64;

    // ========== CONSTRUCTOR ==========

    @noupgrade
    async constructor() {}

    // ========== HELPER FUNCTIONS ==========

    // Calculate minimum price for a tick
    inline get_tick_min_price(tick_id: u64) -> u64 {
        return tick_id * TICK_SIZE;
    }

    // Calculate maximum price for a tick
    inline get_tick_max_price(tick_id: u64) -> u64 {
        return (tick_id + 1u64) * TICK_SIZE;
    }

    // Create unique tick key for mapping
    inline get_tick_key(token_pair: u64, tick_id: u64) -> field {
        return BHP256::hash_to_field(token_pair + (tick_id * 1000000u64));
    }

    // Calculate midpoint execution price
    inline calculate_midpoint_price(buy_limit: u64, sell_limit: u64) -> u64 {
        return (buy_limit + sell_limit) / 2u64;
    }

    // Get minimum of two values
    inline min(a: u64, b: u64) -> u64 {
        return a < b ? a : b;
    }

    // Get maximum of two values
    inline max(a: u64, b: u64) -> u64 {
        return a > b ? a : b;
    }

    // ========== CORE TRANSITIONS ==========

    // Submit a new tick-based order
    transition submit_tick_order(
        public token_pair: u64,
        public is_buy: bool,
        public tick_lower: u64,
        public tick_upper: u64,
        public timestamp: u32,      // Current block height (passed as param)
        limit_price: u64,           // Private: exact price
        quantity: u64               // Private: order size
    ) -> TickOrder {

        // 1. Validate tick range
        let range_width: u64 = tick_upper - tick_lower;
        assert(range_width <= MAX_TICK_RANGE);

        // 2. Verify limit price within declared tick range
        let min_allowed: u64 = get_tick_min_price(tick_lower);
        let max_allowed: u64 = get_tick_max_price(tick_upper);
        assert(limit_price >= min_allowed);
        assert(limit_price <= max_allowed);

        // 3. Ensure quantity is non-zero
        assert(quantity > 0u64);

        // 4. Create the order record
        let order: TickOrder = TickOrder {
            owner: self.caller,
            token_pair,
            tick_lower,
            tick_upper,
            is_buy,
            quantity,
            limit_price,
            filled: 0u64,
            timestamp,
        };

        return order;
    }

    // Settle a matched trade
    // Note: Price verification must be done off-chain or by the caller
    transition settle_match(
        buy_order: TickOrder,
        sell_order: TickOrder,
        public timestamp: u32
    ) -> (TickOrder, TickOrder, Settlement, Settlement) {

        // 1. Verify both orders are for same token pair
        assert(buy_order.token_pair == sell_order.token_pair);

        // 2. Verify buy_order is actually a buy and sell_order is a sell
        assert(buy_order.is_buy == true);
        assert(sell_order.is_buy == false);

        // 3. Verify tick ranges overlap
        let overlap_low: u64 = max(buy_order.tick_lower, sell_order.tick_lower);
        let overlap_high: u64 = min(buy_order.tick_upper, sell_order.tick_upper);
        assert(overlap_low <= overlap_high);

        // 4. Verify actual limit prices cross (buy >= sell)
        assert(buy_order.limit_price >= sell_order.limit_price);

        // 5. Verify prices are within declared tick ranges (anti-fraud)
        assert(buy_order.limit_price >= get_tick_min_price(buy_order.tick_lower));
        assert(buy_order.limit_price <= get_tick_max_price(buy_order.tick_upper));
        assert(sell_order.limit_price >= get_tick_min_price(sell_order.tick_lower));
        assert(sell_order.limit_price <= get_tick_max_price(sell_order.tick_upper));

        // 6. Verify orders have remaining quantity
        assert(buy_order.filled < buy_order.quantity);
        assert(sell_order.filled < sell_order.quantity);

        // 7. Calculate fill quantity
        let buy_remaining: u64 = buy_order.quantity - buy_order.filled;
        let sell_remaining: u64 = sell_order.quantity - sell_order.filled;
        let fill_qty: u64 = min(buy_remaining, sell_remaining);

        // 8. Calculate execution price (midpoint strategy)
        let exec_price: u64 = calculate_midpoint_price(
            buy_order.limit_price,
            sell_order.limit_price
        );

        // 9. Update order filled amounts
        let updated_buy: TickOrder = TickOrder {
            owner: buy_order.owner,
            token_pair: buy_order.token_pair,
            tick_lower: buy_order.tick_lower,
            tick_upper: buy_order.tick_upper,
            is_buy: buy_order.is_buy,
            quantity: buy_order.quantity,
            limit_price: buy_order.limit_price,
            filled: buy_order.filled + fill_qty,
            timestamp: buy_order.timestamp,
        };

        let updated_sell: TickOrder = TickOrder {
            owner: sell_order.owner,
            token_pair: sell_order.token_pair,
            tick_lower: sell_order.tick_lower,
            tick_upper: sell_order.tick_upper,
            is_buy: sell_order.is_buy,
            quantity: sell_order.quantity,
            limit_price: sell_order.limit_price,
            filled: sell_order.filled + fill_qty,
            timestamp: sell_order.timestamp,
        };

        // 10. Create settlement records for both parties
        let buyer_settlement: Settlement = Settlement {
            owner: buy_order.owner,
            token_pair: buy_order.token_pair,
            quantity: fill_qty,
            price: exec_price,
            is_buy: true,
            timestamp,
        };

        let seller_settlement: Settlement = Settlement {
            owner: sell_order.owner,
            token_pair: sell_order.token_pair,
            quantity: fill_qty,
            price: exec_price,
            is_buy: false,
            timestamp,
        };

        return (updated_buy, updated_sell, buyer_settlement, seller_settlement);
    }

    // Cancel an unfilled order
    transition cancel_order(order: TickOrder) -> bool {
        // Only owner can cancel
        assert(order.owner == self.caller);

        // Can only cancel if not fully filled
        assert(order.filled < order.quantity);

        return true;
    }

    // Get order details (for debugging/testing)
    transition get_order_info(order: TickOrder) -> (u64, u64, u64, u64, bool) {
        // Only owner can view their order details
        assert(order.owner == self.caller);

        return (
            order.token_pair,
            order.tick_lower,
            order.tick_upper,
            order.quantity,
            order.is_buy
        );
    }
}

/**
 * DEPLOYMENT INSTRUCTIONS:
 * 
 * 1. Install Leo:
 *    curl https://sh.leo.app | sh
 *    source ~/.bashrc
 * 
 * 2. Build the program:
 *    leo build
 * 
 * 3. Deploy to Aleo testnet (requires Aleo address with credits):
 *    aleo deploy --network testnet3
 * 
 * 4. Check deployment:
 *    aleo info --network testnet3 sl
 * 
 * 5. In production frontend, update contract address in:
 *    - lib/aleo-contract.ts
 *    - hooks/use-aleo.ts
 */
